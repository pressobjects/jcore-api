<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>
<title>JCore API docs: Overview</title>
<meta name="generator" content="PasDoc 0.14.0">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<script type="text/javascript" src="tipuesearch/jquery.min.js"></script>
<script type="text/javascript" src="tipuesearch/tipuesearch_data.js"></script>
<link rel="stylesheet" type="text/css" href="tipuesearch/tipuesearch.css">
<script type="text/javascript" src="tipuesearch/tipuesearch_set.js"></script>
<script type="text/javascript" src="tipuesearch/tipuesearch.js"></script>

<link rel="StyleSheet" type="text/css" href="pasdoc.css">
</head>
<body>
<table class="container"><tr><td class="navigation">
<h2>JCore API docs</h2><p><a href="overview.html" class="navigation">Overview</a></p><p><a href="AllUnits.html" class="navigation">Units</a></p><p><a href="ClassHierarchy.html" class="navigation">Class Hierarchy</a></p><p><a href="AllClasses.html" class="navigation">Classes, Interfaces, Objects and Records</a></p><p><a href="AllTypes.html" class="navigation">Types</a></p><p><a href="AllVariables.html" class="navigation">Variables</a></p><p><a href="AllConstants.html" class="navigation">Constants</a></p><p><a href="AllFunctions.html" class="navigation">Functions and Procedures</a></p><p><a href="AllIdentifiers.html" class="navigation">Identifiers</a></p><p><a href="GVUses.png" class="navigation">Unit dependency graph</a></p><p><a href="GVClasses.png" class="navigation">Classes hierarchy graph</a></p><p><form class="search-form" action="_tipue_results.html"><div class="search-input"><input type="text" name="q" id="tipue_search_input"></div><div class="search-button"><input type="button" id="tipue_search_button" onclick="this.form.submit();"></div></form>
<div style="clear: both"></div>

<script>
$(document).ready(function() {
    $('#tipue_search_input').tipuesearch({
        /* 10 items to display seems standard */
        'show': 10,
        /* For PasDoc docs, showing urls is not very useful,
           since the page title already shows the unit and identifier. */
        'showURL': false
    });
});
</script>
</p></td><td class="content">
<h1 class="externalitem">JCore overview</h1>
 

<p>Open source and object oriented frameworks for Object Pascal.

<p>Truly object oriented Pascal programming assisted by frameworks is a bit challenging. Integration between systems via REST protocol, serialization, deserialization and persistence of objects in a transparent way, dependency injection, integrations without coupling, flexible configuration logs, and the list goes on. Put it all together in an elegant and simple interface, while still being robust and reliable. There are few tools that meet these criteria. JCore is a tool that try hard to deliver most of these requirements to Object Pascal developers as a free and open source library.

<p>Although JCore has been designed with the concept of <a
href="https://en.wikipedia.org/wiki/Convention_over_configuration">Convention over Configuration</a> in mind, it is a premise of the framework to not create services or settings in the initialization area of their units. Therefore you need to manually declare what you want to use. On one hand it makes the initial settings a bit more verbose, on the other hand brings more flexibility and less unexpected behavior.

<p>Another premise used by JCore is to not use global variables. Despite the minimal configuration to build a &quot;Hello World&quot; be a little bigger, avoiding global variables allows you to design the architecture of your application with more freedom. It is for this reason that you need, for example, create and save an OPF configuration instance by yourself.

<p>JCore is divided into modules. The Core module has frameworks and reusable utilities. Each of the other modules depends only on the Core, for example, there is no dependency between OPF and Web Services. Thus if you only need OPF, add only Core and OPF to your project. There are Lazarus packages that can help you to include JCore as dependency, but using Lazarus package is not mandatory. If you don't use Lazarus just point the compiler to the directories of each module you want to add. There is also a Lazarus package with an expert that can help you build your JCore application from scratch.

<p>About Delphi compatibility: JCore is FPC first, and although Delphi compatibility is welcome, I cannot maintain it by myself. Let me know if you can fix the code and can be a maintainer of the Delphi compatibility &mdash; in this case write to joao.morais at pressobjects org.

<p>Welcome aboard! I hope you enjoy using JCore as much as I enjoyed design and build it. =)

<p><h2>Contents:</h2> <ol>
<li><a href="#core">Core</a>
<ol>
<li><a href="#core-dic">Dependency Injection</a>
</li>
<li><a href="#core-expression">Expression Parser</a>
</li>
<li><a href="#core-loggin">Logging</a>
</li>
<li><a href="#core-types">Types</a>
</li>
</ol>
</li>
<li><a href="#opf">OPF</a>
<ol>
<li><a href="#opf-config">Configuration</a>
</li>
<li><a href="#opf-session">Session</a>
<ol>
<li><a href="#opf-session-store">Store</a>
</li>
<li><a href="#opf-session-retrieve">Retrieve</a>
</li>
<li><a href="#opf-session-dispose">Dispose</a>
</li>
<li><a href="#opf-session-stmt">Statement</a>
</li>
<li><a href="#opf-session-criteria">Criteria</a>
</li>
<li><a href="#opf-session-transaction">Transaction control</a>
</li>
</ol>
</li>
<li><a href="#opf-metadata">Metadata</a>
</li>
<li><a href="#opf-oid">OID</a>
</li>
<li><a href="#opf-pid">PID</a>
</li>
<li><a href="#opf-adm">Attributes</a>
</li>
<li><a href="#opf-lazyload">Lazy loading</a>
</li>
</ol>
</li>
<li><a href="#ws">Web Services</a>
</li>
</ol>


<p><hr noshade size="1">

<p><h2 class=""><a name="core"></a>Core</h2>


<p>JCore is divided into modules. This is good because although the product as a whole can become big and meet various kinds of needs, your project must declare and use only what it really need. This is also good for JCore's evolution because the evolution of a module does not impact another module which it does not depend.

<p>The Core module has frameworks and utilities reused by other modules. For example, logging and dependency injection features are useful to any module. Being small frameworks, they are declared in the Core module in order to be shared.

<p>Check out below its main features.

<p><h3 class=""><a name="core-dic"></a>Dependency Injection</h3>


<p>*** On the road

<p><h3 class=""><a name="core-expression"></a>Expression Parser</h3>


<p>*** On the road

<p><h3 class=""><a name="core-loggin"></a>Logging</h3>


<p>*** On the road

<p><h3 class=""><a name="core-types"></a>Types</h3>


<p>*** On the road 

<p><hr noshade size="1">

<p><h2 class=""><a name="opf"></a>OPF</h2>


<p>OPF &mdash; which stands for Object Persistence Framework &mdash; is a library that maps in memory objects to and from a permanent storage, such as a database or flat files. JCoreOPF is the OPF implementation of JCore. The following sections describe a little about this framework.

<p><h3 class=""><a name="opf-config"></a>Configuration</h3>


<p>The building of a JCoreOPF environment begins with the creation of a global variable called <a class="normal" href="JCoreOPFConfig.IJCoreOPFConfiguration.html">Config</a>. The Config responsibility is to maintain overall OPF data such as class and driver parameters, mapping classes, as well as model information such as OID class, generator, attribute types and metadata.

<p>The following code snippets show the most common parameterization of the Config instance.

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>Create the Config instance. Note that the instance is stored in a COM interface, thus there is no need to worry about its life cycle. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      JCoreOPFConfig;
    <span class="pascal_keyword">var</span>
      VConfig: IJCoreOPFConfiguration;
    <span class="pascal_keyword">begin</span>
      VConfig := TJCoreOPFConfiguration.Create;
    </pre>

<p> </p></li>
  <li value="2"><p>Enter a <a class="normal" href="JCoreOPFDriver.TJCoreOPFDriver.html">driver</a> class to be used by the OPF. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      <span class="pascal_comment">// ...</span>
      JCoreOPFDriverSQLdb;
    <span class="pascal_keyword">begin</span>
      <span class="pascal_comment">// ...</span>
      VConfig.DriverClass := TJCoreOPFDriverSQLdb;
    </pre>

<p> </p></li>
  <li value="3"><p>Driver parameterizations. Remember to include any support unit. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      <span class="pascal_comment">// ...</span>
      pqconnection;
    <span class="pascal_keyword">begin</span>
      <span class="pascal_comment">// ...</span>
      <span class="pascal_comment">// 'connection' is the SQLdb's ConnectionName</span>
      VConfig.Params.Values[<span class="pascal_string">'connection'</span>] := <span class="pascal_string">'PostgreSQL'</span>;
      VConfig.Params.Values[<span class="pascal_string">'hostname'</span>] := <span class="pascal_string">'localhost'</span>;
      VConfig.Params.Values[<span class="pascal_string">'database'</span>] := <span class="pascal_string">'mydb'</span>;
      VConfig.Params.Values[<span class="pascal_string">'username'</span>] := <span class="pascal_string">'mydb_user'</span>;
      VConfig.Params.Values[<span class="pascal_string">'password'</span>] := <span class="pascal_string">'passwd'</span>;
    </pre>

<p> </p></li>
  <li value="4"><p>Include all mapping classes that you will need. The class <a class="normal" href="JCoreOPFMappingSQL.TJCoreOPFSQLMapping.html">TJCoreOPFSQLMapping</a> performs auto-mapping and will be the only class required in most cases. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      <span class="pascal_comment">// ...</span>
      JCoreOPFMappingSQL;
    <span class="pascal_keyword">begin</span>
      <span class="pascal_comment">// ...</span>
      VConfig.AddMappingClass([TJCoreOPFSQLMapping]);
    </pre>

<p> </p></li>
  <li value="5"><p>Add the model classes. JCoreOPF need to know all the entity's classes to build the compositions correctly. Adding generics circumvents a generics RTTI limitation in the current version of FPC, this method will be removed as soon as the information is provided by the compiler. </p>

<pre class="longcode">
    <span class="pascal_keyword">begin</span>
      <span class="pascal_comment">// ...</span>
      VConfig.Model.AddClass([
        TPerson, TCity, TInvoice, TInvoiceItem]);
      VConfig.Model.AddGenerics(
        TInvoiceItemList, TInvoiceItem);
    </pre>

<p> </p></li>
  <li value="6"><p>Set the OID. If neither an OID is informed nor an <code>Id</code> property is declared in the entity, JCoreOPF will use a GUID generator and will generate a string key with 32 digits. See <a
    href="#opf-oid">OID</a> for other configuration options of the OID. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      <span class="pascal_comment">// ...</span>
      JCoreOPFOID;
    <span class="pascal_keyword">begin</span>
      <span class="pascal_comment">// ...</span>
      VConfig.Model.OIDClass := TJCoreOPFOIDInt64;
      VConfig.Model.OIDGenerator :=
        TJCoreOPFOIDGeneratorSequence.Create(<span class="pascal_string">'seq_app'</span>);
    </pre>

<p> </p></li>
  <li value="7"><p>All persisted or retrieved entities depend on an internal control object called <a class="normal" href="JCoreOPFMetadata.TJCoreOPFPID.html">PID</a>. The simplest way to meet the requirement in an efficient way is to inherit the entities from the <a class="normal" href="JCoreEntity.TJCoreEntity.html">TJCoreEntity</a> class. Another entity setup options <a href="#opf-pid">here</a>. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      JCoreEntity;
    <span class="pascal_keyword">type</span>
      TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
      <span class="pascal_keyword">private</span>
        FName: <span class="pascal_keyword">string</span>;
      <span class="pascal_keyword">published</span>
        <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
      <span class="pascal_keyword">end</span>;
    </pre>

<p> </p></li>
  <li value="8"><p>Use <a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html">sessions</a> to include, find, change, or delete entities in the persistence mechanism. See other Session use samples <a href="#opf-session">here</a>. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      <span class="pascal_comment">// ...</span>
      JCoreOPFSession;
    <span class="pascal_keyword">var</span>
      <span class="pascal_comment">// ...</span>
      VSession: IJCoreOPFSession;
    <span class="pascal_keyword">begin</span>
      <span class="pascal_comment">// ...</span>
      VSession := VConfig.CreateSession;
      VSession.Store(<span class="pascal_numeric"></span>...);
    </pre>

<p> </p></li>
</ol>

<p>

<p>The configurations above are the minimum necessary for building a functional JCoreOPF environment. The following topics discuss these configuration options in a little more detail.

<p>Time to take a cup of coffee.

<p><h3 class=""><a name="opf-session"></a>Session</h3>


<p>To add, find, change or delete objects you need to create Sessions. While the Config instance is thread safe, the persistent sessions are not.

<p><b>Important:</b> in multithreaded applications, do create a new Session for each new thread.

<p><h4 class=""><a name="opf-session-store"></a>Store</h4>


<p>Use the <a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Store">Store</a> method to store a new entity or change an existing one in the database.

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    JCoreOPFSession;
  <span class="pascal_keyword">var</span>
    <span class="pascal_comment">// ...</span>
    VSession: IJCoreOPFSession;
    VPerson: TPerson;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VSession := VConfig.CreateSession;
    VPerson := TPerson.Create;
    <span class="pascal_keyword">try</span>
      VPerson.<span class="pascal_keyword">Name</span> := <span class="pascal_string">'jack'</span>;
      VSession.Store(VPerson);
      <span class="pascal_comment">// oops, wrong name</span>
      VPerson.<span class="pascal_keyword">Name</span> := <span class="pascal_string">'james'</span>;
      VSession.Store(VPerson);
    <span class="pascal_keyword">finally</span>
      FreeAndNil(VPerson);
    <span class="pascal_keyword">end</span>;
</pre>

<p>

<p><h4 class=""><a name="opf-session-retrieve"></a>Retrieve</h4>


<p>To retrieve an object whose <code>Id</code> is known use the method <a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Retrieve">Retrieve</a>.

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">var</span>
    <span class="pascal_comment">// ...</span>
    VPerson: TPerson;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VPerson := VSession.Retrieve(TPerson, [<span class="pascal_string">'1'</span>]) <span class="pascal_keyword">as</span> TPerson;
    <span class="pascal_keyword">try</span>
      <span class="pascal_comment">// ...</span>
    <span class="pascal_keyword">finally</span>
      FreeAndNil(VPerson);
    <span class="pascal_keyword">end</span>;
</pre>

<p>

<p>The interface of the <a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Retrieve">Retrieve</a> method is unique to any OID type and expects the Id in string format. JCoreOPF converts to the correct format before searching on the database.

<p><h4 class=""><a name="opf-session-dispose"></a>Dispose</h4>


<p>To delete an object from the database use one of two <a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Dispose">Dispose</a> method approaches.

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>With one instance: </p>

<pre class="longcode">
  <span class="pascal_keyword">var</span>
    <span class="pascal_comment">// ...</span>
    VPerson: TPerson;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VSession.Dispose(VPerson);
    </pre>

<p> </p></li>
  <li value="2"><p>With just the class and the <code>Id</code>: </p>

<pre class="longcode">
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VSession.Dispose(TPerson, [<span class="pascal_string">'1'</span>]);
    </pre>

<p> </p></li>
</ol>

<p>

<p><h4 class=""><a name="opf-session-stmt"></a>Statement</h4>


<p>Use <a class="normal" href="JCoreOPFDriver.IJCoreOPFSQLStatement.html">statements</a> to run queries or change data without using the JCoreOPF mapping.

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>Updating data: </p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    JCoreOPFDriver;
  <span class="pascal_keyword">var</span>
    <span class="pascal_comment">// ...</span>
    VStmt: IJCoreOPFSQLStatement;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VStmt := VSession.CreateStatement;
    VStmt.SQL := <span class="pascal_string">'UPDATE person SET name=? WHERE id=?'</span>;
    VStmt.WriteString(<span class="pascal_string">'james'</span>);
    Vstmt.WriteInt64(<span class="pascal_numeric">1</span>);
    VStmt.ExecuteImmediate;
    </pre>

<p> </p></li>
  <li value="2"><p>Querying data: </p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    JCoreOPFDriver;
  <span class="pascal_keyword">var</span>
    <span class="pascal_comment">// ...</span>
    VStmt: IJCoreOPFSQLStatement;
    VResultSet: IJCoreOPFSQLResultSet;
    I: Integer;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VStmt := VSession.CreateStatement;
    VStmt.SQL := <span class="pascal_string">'SELECT name FROM person p WHERE p.nick=?'</span>;
    VStmt.WriteString(<span class="pascal_string">'joe'</span>);
    VResultSet := VStmt.OpenCursor;
    <span class="pascal_keyword">for</span> I := <span class="pascal_numeric">0</span> <span class="pascal_keyword">to</span> Pred(VResultSet.Size) <span class="pascal_keyword">do</span>
      writeln(<span class="pascal_string">'Name: '</span>, VResultSet.ReadString);
    </pre>

<p> </p></li>
</ol>

<p>

<p><h4 class=""><a name="opf-session-criteria"></a>Criteria</h4>


<p>Unlike statements, <a class="normal" href="JCoreOPFCriteria.IJCoreOPFSQLCriteria.html">criteria</a> uses JCoreOPF mapping for querying the database. This way it can retrieve an object or a list of objects instead of a cursor.

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>Filtering by <a class="normal" href="JCoreOPFCriteriaSQL.TJCoreOPFCriteriaRestriction.html">criterions</a>: </p>

<pre class="longcode">
  <span class="pascal_keyword">var</span>
    VPersonList: TObjectList;
  <span class="pascal_keyword">begin</span>
    VPersonList := Session.CreateCriteria(TPerson)
      <span class="pascal_float">.</span>Add(TJCoreOPFCriteriaRestriction.Gt(<span class="pascal_string">'age'</span>, <span class="pascal_numeric">18</span>))
      <span class="pascal_float">.</span>RetrieveList;
    </pre>

<p> </p></li>
  <li value="2"><p>Filtering by SQL code: </p>

<pre class="longcode">
  <span class="pascal_keyword">var</span>
    VPersonList: TObjectList;
  <span class="pascal_keyword">begin</span>
    VPersonList := Session.CreateCriteria(TPerson)
      <span class="pascal_float">.</span>Add(TJCoreOPFCriteriaRestriction.SQL(<span class="pascal_string">'age &gt; ?'</span>, [<span class="pascal_numeric">18</span>]))
      <span class="pascal_float">.</span>RetrieveList;
    </pre>

<p> </p></li>
  <li value="3"><p>Returning none or just one object: </p>

<pre class="longcode">
  <span class="pascal_keyword">var</span>
    VPerson: TPerson;
  <span class="pascal_keyword">begin</span>
    VPerson := Session.CreateCriteria(TPerson)
      <span class="pascal_float">.</span>Add(TJCoreOPFCriteriaRestriction.Eq(<span class="pascal_string">'name'</span>, <span class="pascal_string">'jack'</span>))
      <span class="pascal_float">.</span>RetrieveUnique <span class="pascal_keyword">as</span> TPerson;
    </pre>

<p> </p></li>
</ol>

<p>

<p><h4 class=""><a name="opf-session-transaction"></a>Transaction control</h4>


<p>*** Unstable usage interface

<p><h3 class=""><a name="opf-metadata"></a>Metadata</h3>


<p>Metadatas are used to store model settings. Only part of the metadata can be configured directly at the entity's declaration, whose reading is made by JCoreOPF via RTTI. Other settings can only be made searching and changing the metadata at runtime. We look forward the FPC's <a
href="http://wiki.freepascal.org/Property_attributes">property attributes</a> implementation. =)

<p>Declaring a string of 50 chars in length and a composition:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    JCoreEntity;
  <span class="pascal_keyword">type</span>
    <span class="pascal_comment">// ...</span>
    TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_comment">// ... private fields</span>
    <span class="pascal_keyword">published</span>
      <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">index</span> <span class="pascal_numeric">50</span>;
      <span class="pascal_keyword">property</span> Address: TAddress <span class="pascal_keyword">stored</span> True;
    <span class="pascal_keyword">end</span>;
</pre>

<p>

<p>Compositions cannot be shared with more than one object and are destroyed when the object that references it is destroyed (<a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Dispose">Dispose</a>). If the <code>stored</code> option is not informed, by default JCoreOPF creates a composition.

<p>Declaring a string of 100 chars in length and an aggregation:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    JCoreEntity;
  <span class="pascal_keyword">type</span>
    TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_comment">// ... private fields</span>
    <span class="pascal_keyword">published</span>
      <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">index</span> <span class="pascal_numeric">100</span>;
      <span class="pascal_keyword">property</span> City: TCity <span class="pascal_keyword">stored</span> False;
    <span class="pascal_keyword">end</span>;
</pre>

<p>

<p>Aggregations can be shared among multiple objects and are not destroyed when the object that references it is destroyed.

<p><b>Important:</b> while data within compositions are sent to the database whenever the main object is updated (<a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Store">Store</a>), this only happens with aggregations when it does not yet exist in the database. To update the data from an aggregation &mdash; <code>Person.City</code> in the above example &mdash; you must explicitly call the <a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Store">Store</a> method for the <code>City</code> instance.

<p>Declaring a list composition:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    fgl,
    JCoreEntity;
  <span class="pascal_keyword">type</span>
    TInvoiceItem = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_comment">// ... private fields and published properties</span>
    <span class="pascal_keyword">end</span>;

    TInvoiceItemList = 
      <span class="pascal_keyword">specialize</span> TFPGObjectList&lt;TInvoiceItem&gt;;

    TInvoice = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_comment">// ... private fields</span>
    <span class="pascal_keyword">published</span>
      <span class="pascal_keyword">property</span> Items: TInvoiceItemList
        <span class="pascal_keyword">read</span> FItems <span class="pascal_keyword">write</span> FItems;
    <span class="pascal_keyword">end</span>;
</pre>

<p>

<p><b>Important:</b> note that the entity's memory management is a responsibility of the programmer. The code snippet above declares one of the types natively supported by JCoreOPF, however the control of the entity's life cycle and all its attributes should be treated. To complete the example above is necessary to overload the <code>Destroy</code> and implement <code>FreeAndNil(FItems)</code>. Moreover, to simplify the user interface is recommended to use getter and setter, respectively, to create the list if it does not exist and to destroy the old list before assigning a new one.

<p>Because of a generics RTTI limitation on FPC, whenever declaring a generic list you must register it with the Model. The configuration below allows the JCoreOPF to know that <code>TInvoiceItemList</code> is a list of <code>TInvoiceItem</code>.

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VConfig.Model.AddGenerics(
      TInvoiceItemList, TInvoiceItem);
</pre>

<p>

<p>The list compositions have the same behavior of simple compositions, ie, all items are destroyed when the main object is destroyed, and all the items that has changed will be updated in the database when the main object is updated (<a class="normal" href="JCoreOPFSession.IJCoreOPFSession.html#Store">Store</a>).

<p>Declaring a list aggregation:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    fgl;
    JCoreEntity;
  <span class="pascal_keyword">type</span>
    TLanguage = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_comment">// ... private fields and published properties</span>
    <span class="pascal_keyword">end</span>;

    TLanguageList = <span class="pascal_keyword">specialize</span> TFPGObjectList&lt;TLanguage&gt;;

    TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_comment">// ... private fields</span>
    <span class="pascal_keyword">published</span>
      <span class="pascal_keyword">property</span> SpokingLanguages: TLanguageList
        <span class="pascal_keyword">read</span> FSpokingLanguages <span class="pascal_keyword">write</span> FSpokingLanguages;
        <span class="pascal_keyword">stored</span> False;
    <span class="pascal_keyword">end</span>;
</pre>

<p>

<p>Worth the same hints of list compositions: destroy the list whenever you destroy the entity and use as a good practice to declare getter and setter to control the list lifecycle.

<p>List aggregations has the same behavior of simple aggregations:

<p></p>

<ul class="paragraph_spacing">
  <li><p>Each item (<code>TLanguage</code>) can be shared with more than one entity (<code>TPerson</code>) </p></li>
  <li><p>Changes in the data items (<code>TLanguage</code>) will not be sent to the database when saving the entity (<code>TPerson</code>), unless they are not there yet </p></li>
  <li><p>Only the links to the items (<code>TLanguage</code>) will be destroyed when the entity (<code>TPerson</code>) is destroyed, that is, by excluding <code>TPerson</code>, each <code>TLanguage</code> that it references remain on the database </p></li>
</ul>

<p>

<p>JCoreOPF automatically recognizes the published properties and their types without the need for manual intervention. To adjust any setting that is not possible using RTTI, it is necessary to search and modify the metadata of a <a class="normal" href="JCoreOPFMetadata.TJCoreOPFClassMetadata.html">class</a> or an <a class="normal" href="JCoreOPFMetadata.TJCoreOPFAttrMetadata.html">attribute</a> manually.

<p>Search the <a class="normal" href="JCoreMetadata.TJCoreClassMetadata.html">class metadata</a> of <code>TPerson</code> class and change it's generator:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VConfig.Model.AcquireMetadata(TPerson)<span class="pascal_float">.</span>OIDGenerator :=
      TJCoreOPFOIDGeneratorSequence.Create(<span class="pascal_string">'seq_person'</span>);
</pre>

<p>

<p>Search the <a class="normal" href="JCoreOPFMetadata.TJCoreOPFAttrMetadata.html">attribute metadata</a> of <code>TPerson.Name</code> attribute and change the name of it's field in the database:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VConfig.Model.AcquireAttrMetadata(TPerson, <span class="pascal_string">'Name'</span>)
      <span class="pascal_float">.</span>PersistentFieldName := <span class="pascal_string">'PERSON_NAME'</span>;
</pre>

<p>

<p><h3 class=""><a name="opf-oid"></a>OID</h3>


<p>Every entity persisted in the database needs a means to be referenced when loaded into memory. In JCoreOPF this is done with <a class="normal" href="JCoreOPFMetadata.TJCoreOPFModel.html#OIDClass">OID management</a> class and <a class="normal" href="JCoreOPFMetadata.TJCoreOPFModel.html#OIDGenerator">OID Generator</a> instance. The former sets the class whose instance will control the OID data itself, the latter will be used whenever a new OID need to be created.

<p>Each of the model classes have an implicit OID that can be customized. If no customization is applied, JCoreOPF will create a GUID, store it in a field named Id, and expects that the field supports a string of 32 chars in length.

<p>To globally change the OID generator to the database's sequence <code>seq_app</code> and store it in a field named <code>Id</code> whose type is <code>Int64</code>:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    JCoreOPFOID;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VConfig.Model.OIDClass := TJCoreOPFOIDInt64;
    VConfig.Model.OIDGenerator :=
      TJCoreOPFOIDGeneratorSequence.Create(<span class="pascal_string">'seq_app'</span>);
</pre>

<p>

<p>If you prefer to use an auto-increment field or if the database does not support sequences:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">uses</span>
    <span class="pascal_comment">// ...</span>
    JCoreOPFOID;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VConfig.Model.OIDClass := TJCoreOPFOIDInt64;
    VConfig.Model.OIDGenerator :=
      TJCoreOPFOIDGeneratorAutoinc.Create;
</pre>

<p>

<p>It is possible to use a different generator for each model class:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VConfig.Model.OIDClass := TJCoreOPFOIDInt64;
    VConfig.Model.AcquireMetadata(TPerson)<span class="pascal_float">.</span>OIDGenerator :=
      TJCoreOPFOIDGeneratorSequence.Create(<span class="pascal_string">'seq_person'</span>);
    VConfig.Model.AcquireMetadata(TInvoice)<span class="pascal_float">.</span>OIDGenerator :=
      TJCoreOPFOIDGeneratorSequence.Create(<span class="pascal_string">'seq_invoice'</span>);
    VConfig.Model.AcquireMetadata(TCity)<span class="pascal_float">.</span>OIDGenerator :=
      TJCoreOPFOIDGeneratorSequence.Create(<span class="pascal_string">'seq_city'</span>);
</pre>

<p>

<p><b>Important:</b> on inheritances, the same OID is shared between all subclasses. If a model entity inherits from another persistent entity, only the most abstract class may set a custom OID and generator.

<p>The contents of the OID is always available in <a class="normal" href="JCoreEntity.IJCorePID.html#OID">IJCorePID.OID</a>, see <a
href="#opf-pid">PID</a> for information on how to declare the PID.

<p>*** Unstable usage interfaces, so missing doc:

<p></p>

<ul class="paragraph_spacing">
  <li><p>declare an OID using RTTI</p></li>
  <li><p>declare an OID from the attribute metadata</p></li>
  <li><p>name the PersistentField of an OID</p></li>
</ul>

<p>

<p>The OID architecture of JCoreOPF was built in such a way to allow the use of compound OID, however this feature is not implemented yet.

<p><h3 class=""><a name="opf-pid"></a>PID</h3>


<p><a class="normal" href="JCoreOPFMetadata.TJCoreOPFPID.html">PID</a> is a JCoreOPF internal instance with persistence and metadata information of the entity, widely used in the internal implementation of the framewowk. There is a different <code>PID</code> instance for each persistent entity loaded into memory, thus it &mdash; the <code>PID</code> &mdash; should be destroyed whenever its entity is destroyed.

<p>A <code>PID</code> is created whenever an entity is retrieved from the database or whenever a non-persistent entity is stored in the database. JCoreOPF takes care of the construction of the <code>PID</code>, and depending on how the entity is declared, it's the programmer's responsibility to destroy the <code>PID</code> whenever the entity is destroyed.

<p>To declare an entity, use any of the following four approaches.

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>Inherits from <a class="normal" href="JCoreEntity.TJCoreEntity.html">TJCoreEntity</a>. </p>

<pre class="longcode">
  TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
  <span class="pascal_keyword">private</span>
    FName: <span class="pascal_keyword">string</span>;
  <span class="pascal_keyword">published</span>
    <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
  <span class="pascal_keyword">end</span>;
    </pre>

<p> </p></li>
  <li value="2"><p>Declare the <code>_proxy</code> attribute as <a class="normal" href="JCoreEntity.TJCoreEntityProxy.html">TJCoreEntityProxy</a> before entity's private area. When using this approach is necessary to inherit the entity from <code>TPersistent</code> or use the compiler directive <code>{$M+}</code>, so that the framework can locate the <code>_proxy</code> attribute at runtime. </p>

<pre class="longcode">
  <span class="pascal_compiler_comment">{$M+}</span>
  TPerson = <span class="pascal_keyword">class</span>(TObject)
    _proxy: TJCoreEntityProxy;
  <span class="pascal_keyword">private</span>
    FName: <span class="pascal_keyword">string</span>;
  <span class="pascal_keyword">public</span>
    <span class="pascal_comment">// Destructor implements FreeAndNil(_proxy);</span>
    <span class="pascal_keyword">destructor</span> Destroy; <span class="pascal_keyword">override</span>;
  <span class="pascal_keyword">published</span>
    <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
  <span class="pascal_keyword">end</span>;
  <span class="pascal_compiler_comment">{$M+}</span>
    </pre>

<p> </p></li>
  <li value="3"><p>Declare the <code>_pid</code> property as <a class="normal" href="JCoreEntity.IJCorePID.html">IJCorePID</a> at the published area of the entity. </p>

<pre class="longcode">
  TPerson = <span class="pascal_keyword">class</span>(TObject)
  <span class="pascal_keyword">private</span>
    FPID: IJCorePID;
    FName: <span class="pascal_keyword">string</span>;
  <span class="pascal_keyword">published</span>
    <span class="pascal_keyword">property</span> _pid: IJCorePID <span class="pascal_keyword">read</span> FPID <span class="pascal_keyword">write</span> FPID;
    <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
  <span class="pascal_keyword">end</span>;
    </pre>

<p> </p></li>
  <li value="4"><p>Do not declare any <code>PID</code> or <code>Proxy</code> reference and leave JCoreOPF find the <code>PID</code> by itself. When using this approach it is necessary to notify JCoreOPF the destruction of the entity using the <a class="normal" href="JCoreOPFMetadata.TJCoreOPFModel.html#ReleaseEntity">ReleaseEntity</a> method. </p>

<pre class="longcode">
  <span class="pascal_comment">// Model unit</span>
  TPerson = <span class="pascal_keyword">class</span>(TObject)
  <span class="pascal_keyword">private</span>
    FId: Integer;
    FName: <span class="pascal_keyword">string</span>;
  <span class="pascal_keyword">public</span>
    <span class="pascal_comment">// Destructor implements VModel.ReleaseEntity(Self)</span>
    <span class="pascal_keyword">destructor</span> Destroy; <span class="pascal_keyword">override</span>;
  <span class="pascal_keyword">published</span>
    <span class="pascal_keyword">property</span> Id: Integer <span class="pascal_keyword">read</span> FId <span class="pascal_keyword">write</span> FId;
    <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
  <span class="pascal_keyword">end</span>;
  <span class="pascal_comment">// ...</span>
  <span class="pascal_keyword">var</span>
    VModel: IJCoreModel;
  
  <span class="pascal_comment">// Configuration unit</span>
  <span class="pascal_keyword">begin</span>
    <span class="pascal_comment">// ...</span>
    VModel := VConfig.Model;
    </pre>

<p> </p></li>
</ol>

<p>

<p>Which approach to use? Inherit the entity from <a class="normal" href="JCoreEntity.TJCoreEntity.html">TJCoreEntity</a> if the entity does not have to inherit from another class, otherwise declare the <code>_proxy</code> attribute or the <code>_pid</code> property. While <code>_pid</code> has the advantage of not needing to be destroyed manually, <code>_proxy</code> has the advantage that it can be called even before the framework initializes it &mdash; calling a <code>Nil</code> <code>_proxy</code> is safe. All of these three approaches have the same performance.

<p>The lack of a reference to the <code>PID</code> in the entity's declaration has a little impact on performance and leaves the entity without support of some features such as lazy loading. In this approach it is necessary to <a class="normal" href="JCoreOPFMetadata.TJCoreOPFModel.html#ReleaseEntity">notify</a> JCoreOPF of the entity's destruction. If the <code>PID</code> is not released when the instance is destroyed, it will be released only when its session is destroyed.

<p>*** There is an undocumented feature regarding a native <code>Id</code> property. The usage interface of this feature isn't stable yet.

<p><h3 class=""><a name="opf-adm"></a>Attributes</h3>


<p>The Mediation between the persistence engine and JCoreOPF's mapping is done through <a class="normal" href="JCoreOPFMetadata.TJCoreOPFADM.html">ADM</a> &mdash; Attribute Data Mediator &mdash; instances. The creation and destruction of ADMs is handled by the framework.

<p>JCoreOPF has three distinct types of ADM implementations. All the types has the same performance, adopt one that suit you best.

<p></p>

<ol class="paragraph_spacing">
  <li value="1"><p>ADM for native types &mdash; they are used with native compiler types. It has the advantage of simplicity and the disadvantage of not supporting <code>null</code>. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      JCoreEntity;
    <span class="pascal_keyword">type</span>
      TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
      <span class="pascal_comment">// ... private fields</span>
      <span class="pascal_keyword">published</span>
        <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: <span class="pascal_keyword">string</span> <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
        <span class="pascal_keyword">property</span> Age: Integer <span class="pascal_keyword">read</span> FAge <span class="pascal_keyword">write</span> FAge;
      <span class="pascal_keyword">end</span>;
    </pre>

<p> </p></li>
  <li value="2"><p>ADM for object types &mdash; they are used in attributes managed as objects. JCore has interfaces and support classes to various native types, see unit <a class="normal" href="JCoreTypes.html">JCoreTypes</a>. It has the advantage of supporting <code>null</code> and the disadvantage of a more verbose syntax &mdash; <code>VPerson.Name.Value</code> &mdash; to access the native content. The JCore Types are immutable, thus it is safe to reference the object instead of copying the native content. </p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      JCoreEntity,
      JCoreTypes;
    <span class="pascal_keyword">type</span>
      TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
      <span class="pascal_comment">// ... private fields</span>
      <span class="pascal_keyword">published</span>
        <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: IJCoreString <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
        <span class="pascal_keyword">property</span> Age: IJCoreInteger <span class="pascal_keyword">read</span> FAge <span class="pascal_keyword">write</span> FAge;
      <span class="pascal_keyword">end</span>;
    </pre>

<p> </p></li>
  <li value="3"><p>ADM as attribute &mdash; the ADM itself is used in place of the native attribute or attribute as object. It has the advantage of grouping in the same interface: support of <code>null</code>, flag for modified content, cached content and other internal informations from the ADM. The disadvantages are: the need to keep a reference to the Model in order to initialize the attributes, a more verbose syntax &mdash; <code>VPerson.Name.Value</code> &mdash; to access the content, and a small overhead during construction of the instance.

<p></p>

<pre class="longcode">
    <span class="pascal_keyword">uses</span>
      JCoreEntity,
      JCoreOPFADM;
    <span class="pascal_keyword">type</span>
      TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
      <span class="pascal_comment">// ... private fields</span>
      <span class="pascal_keyword">public</span>
        <span class="pascal_keyword">procedure</span> AfterConstruction; <span class="pascal_keyword">override</span>;
      <span class="pascal_keyword">published</span>
        <span class="pascal_keyword">property</span> <span class="pascal_keyword">Name</span>: TJCoreOPFStringType
          <span class="pascal_keyword">read</span> FName <span class="pascal_keyword">write</span> FName;
        <span class="pascal_keyword">property</span> Age: TJCoreOPFIntegerType
          <span class="pascal_keyword">read</span> FAge <span class="pascal_keyword">write</span> FAge;
      <span class="pascal_keyword">end</span>;
    <span class="pascal_keyword">implementation</span>
    <span class="pascal_comment">// ...</span>
    <span class="pascal_keyword">procedure</span> TPerson.AfterConstruction;
    <span class="pascal_keyword">begin</span>
      VModel.InitEntity(Self);
    <span class="pascal_keyword">end</span>;
    </pre>

<p>

<p><b>Important:</b> an ADM belongs to a single attribute of a single instance and it is not an immutable object. Copying data should always be made from the native value instead of referencing the attribute object.

<p>The <code>VModel</code> variable is used to create the entity's ADMs in the ADM as attribute approach. It's content must be initialized just after the creation of the Config instance.

<p></p>

<pre class="longcode">
    <span class="pascal_comment">// Model unit</span>
    <span class="pascal_keyword">type</span>
      TPerson = <span class="pascal_keyword">class</span>(TJCoreEntity)
      <span class="pascal_comment">// ...</span>
    <span class="pascal_keyword">var</span>
      VModel: IJCoreModel;

    <span class="pascal_comment">// Configuration instance unit</span>
    <span class="pascal_keyword">begin</span>
      VConfig := TJCoreOPFConfiguration.Create;
      VModel := VConfig.Model;
    </pre>

<p>

<p><b>Important:</b> unlike native attributes, the ADM as attribute lifecycle is managed by JCoreOPF. Do not create nor destroy them by hand, instead create them using <a class="normal" href="JCoreEntity.IJCoreModel.html#InitEntity">InitEntity</a> method and leave <code>PID</code> destroy them. </p></li>
</ol>

<p>

<p><h3 class=""><a name="opf-lazyload"></a>Lazy loading</h3>


<p>Lazy loading is a feature that allows the entity to be partially loaded. Some attributes like blobs or lists might be configured to be loaded only if the information is actually required.

<p>Setting up a list of product items to be loaded on demand:

<p></p>

<pre class="longcode">
  <span class="pascal_keyword">type</span>
    TInvoice = <span class="pascal_keyword">class</span>(TJCoreEntity)
    <span class="pascal_keyword">private</span>
      FItems: TInvoiceItemList;
      <span class="pascal_keyword">function</span> GetItems: TInvoiceItemList;
      <span class="pascal_keyword">procedure</span> SetItems(<span class="pascal_keyword">const</span> AValue: TInvoiceItemList);
    <span class="pascal_keyword">published</span>
      <span class="pascal_keyword">property</span> Items: TInvoiceItemList
        <span class="pascal_keyword">read</span> GetItems <span class="pascal_keyword">write</span> SetItems;
    <span class="pascal_keyword">end</span>;
  <span class="pascal_keyword">implementation</span>
  <span class="pascal_comment">// ...</span>
  <span class="pascal_keyword">function</span> TInvoice.GetItems: TInvoiceItemList;
  <span class="pascal_keyword">begin</span>
    <span class="pascal_keyword">if</span> <span class="pascal_keyword">not</span> _proxy.Lazyload(@FItems) <span class="pascal_keyword">then</span>
      FItems := TInvoiceItemList.Create(True);
    Result := FItems;
  <span class="pascal_keyword">end</span>;
</pre>

<p>

<p>The lazy load syntax in depth:

<p></p>

<ul class="paragraph_spacing">
  <li><p>Declare a getter in every attribute you want to load on demand</p></li>
  <li><p>Call <a class="normal" href="JCoreEntity.TJCoreEntityProxy.html#Lazyload">_proxy.Lazyload</a> method sending the <i>address</i> of the attribute in the only parameter available. If <code>_pid</code> property approach is used, call <a class="normal" href="JCoreEntity.IJCorePID.html#Lazyload">_pid.Lazyload</a> instead after ensure that <code>_pid</code> is not <code>Nil</code></p></li>
  <li><p>If the method returns <code>True</code> JCoreOPF has already loaded the data and updated the attribute, no further action is required. Just return the attribute value</p></li>
  <li><p>If the method returns <code>False</code> JCoreOPF could not load the data or update the attribute, you should create a valid reference just like if lazy loading was not configured</p></li>
</ul>

<p>

<p>How does the feature work? Whenever the getter of a property is set with a call to the <a class="normal" href="JCoreEntity.TJCoreEntityProxy.html#Lazyload">LazyLoad</a> method, JCoreOPF recognizes that call and flags the attribute to not be loaded from the database. The implementation of the getter delegates to JCoreOPF the responsibility to load the data. On success or if the data have already been loaded, the method returns <code>True</code> indicating success. If JCoreOPF cannot load or create the data, the method returns <code>False</code> which means the framework didn't touch the attribute and the getter should take care of the request.

<p>The lazy loading of JCoreOPF works with any attribute type, although it makes more sense with lists and attributes that have a lot of content and little use. 

<p><hr noshade size="1">

<p><h2 class=""><a name="ws"></a>Web Services</h2>


<p>*** On the road <hr noshade size="1"><span class="appinfo"><em>Generated by <a  href="http://pasdoc.sourceforge.net/">PasDoc 0.14.0</a>. </em>
</span>
</td></tr></table></body></html>
